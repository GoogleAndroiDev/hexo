---
title: 聊一聊 "类加载器"
layout: post
date: 2019-03-01
comments: true
categories: Java
tags: [类加载] 
---

**阅读本文你能收获到**

* 了解 Java/Android中类加载器及其工作流程
* Android 开发过程中类加载器的应用场景

<h3 id="1">类加载器</h3>
类加载器是虚拟机运行时动态加载字节码文件的入口。注意这里的虚拟机并不特指 Java虚拟机 或 Android虚拟机。通常来说开发者写的代码经过“前端编译器”编译成字节码文件集（Java-jar, Android-dex等）之后交给虚拟机，而虚拟机加载这些字节码文件集就是通过类加载器完成。

应用程序包的字节码文件集是经过“前段编译器”精挑细选得到的，程序运行所需要的任意代码及资源都被打进程序包中。但实际上用户在使用程序时往往难以走遍程序所有逻辑，因此虚拟机只需按需加载当前用户场景所涉及到的代码。这便决定了类加载器的加载场景 “按需加载”。


应用程序包实际运行是依赖“运行环境”的。比如 Java 程序需要依赖 JRE 进行运行，而 Android 程序则依赖 Application Framework。当然这里讨论的仅仅是下面第一层，更下层的还有Kernel等不在讨论范围内。而这些环境运行时提供了运行程序库依赖的支持。如果应用程序包中使用了运行环境中的类，那运行时这部分类该如何加载？ 同时，应用程序内的类又是如何加载的呢？ 事实上，虚拟机对要加载的类进行“域”划分，不同“域”的加载委托给不同的类加载器进行加载，这种加载模式称为 “委托加载”。

先看下 Java 和 Android 平台提供哪些类加载器。

<h4 id="1_1">Java 流派</h4>

Java系统主要提供了 3 种类加载器

1. `Bootstrap Classloader `，启动类加载器，负责加载 \lib 目录下或者被 -Xbootclasspath参数所指定的路径种的，能被虚拟机识别的类库 （即所有 java.* 开头的类）。
2. `Extension Classloader `，扩展类加载器，负责加载 \lib\ext 目录下或者被 java.ext.dirs 系统变量指定路径的类库（例如所有 javax.* 开头的类和存放在 JRE 的 ext 目录下的类）。
3. `Application Classloader `，应用程序类加载器，负责加载用户类路径指定的类库，开发者可以直接使用这个类加载器（即我们自己写的 Java程序时新创建的类都是通过它来接在的）。


<h4 id="1_2">Android 流派</h4>

Android系统也提供了多种类加载器, 这些类加载器都有 `java.lang.ClassLoader` 继承而来。

已目前 `Android P` 源码显示, 其类图如下。



1. `bootclassloader`, Android系统启动的时候创建该实例，用于加载framework层类，当应用程序也需要用到这些类的时候，会在应用程序启动的时候传递该实例给程序。
2. `pathclassloader`, 只能加载系统中已经安装过的apk
3. `dexclassloader`，可以加载jar/apk/dex，可以从SD卡中加载未安装的apk



<h4 id="1_3">委托加载 </h4>
除了系统提供的类加载，开发者一般也可以自定义 ClassLoader，结合系统提供的类加载器，整个应用程序加载流程中它们有着严格的加载逻辑, 按照 ”按需加载，委托加载“ 的思想组合起来一起完成整个程序的类加载，这种加载模型成为 ”双亲委派模型“。

以 Android 类加载为例子，这里画了个模型。


ClassLoader

BaseDexClassLoader 

DexClassLoader
PathClassLoader
InMemoryDexClassLoader
DelegateLastClassLodaer

SecureClassLoader

URLClassLoader


[ClassLoader#loadClass](https://android.googlesource.com/platform/libcore/+/refs/heads/master/ojluni/src/main/java/java/lang/ClassLoader.java#359)




这里xxx画个模型 
其工作流程大致如下： 
当一个类加载器收到类加载的请求是，首先自己不会加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此。因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。


### 类加载器类别
#### BootClassLoader
在系统启动的时候回创建一个boot类型的classloader实例，用于加载一些听framework层的类。android 应用中也需要用到一些系统的类，所以在app启动的时候也会把这个bootclassloader传递进来。

#### pathClassLoader
PathClassLoader只能加载系统中已经安装过的apk
实际上，每个app需要加载自己类，这些类放在apk的dex文件中
```
在application中获取classLoader
ClassLoader classloader = getClassLoader（）
```
实际上获取的dalvik.system.PathClassPath.
```
public class PathClassLoader extends BaseDexClassLoader {
    public PathClassLoader(String dexPath, ClassLoader parent) {
        super((String)null, (File)null, (String)null, (ClassLoader)null);
        throw new RuntimeException("Stub!");
    }

    public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) {
        super((String)null, (File)null, (String)null, (ClassLoader)null);
        throw new RuntimeException("Stub!");
    }
}
//其父类实现为
public BaseDexClassLoader(String dexPath, File optimizedDirectory,
            String libraryPath, ClassLoader parent) {
        super(parent);
        this.originalPath = dexPath;
        this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory);
    }
//创建dexpathlist
    public DexPathList(ClassLoader definingContext, String dexPath,
            String libraryPath, File optimizedDirectory) {
        ……
        this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory);
    }

    private static Element[] makeDexElements(ArrayList<File> files,
            File optimizedDirectory) {
        ArrayList<Element> elements = new ArrayList<Element>();
        for (File file : files) {
            ZipFile zip = null;
            DexFile dex = null;
            String name = file.getName();
            if (name.endsWith(DEX_SUFFIX)) {
                dex = loadDexFile(file, optimizedDirectory);
            } else if (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX)
                    || name.endsWith(ZIP_SUFFIX)) {
                zip = new ZipFile(file);
            }
            ……
            if ((zip != null) || (dex != null)) {
                elements.add(new Element(file, zip, dex));
            }
        }
        return elements.toArray(new Element[elements.size()]);
    }

//构建dexfile，optimezeDirectory是一个缓存加载dex的文件，如果存在则返直接返回。
//dexclassloader可以指定自己的optimized，用于加载外部dex
    private static DexFile loadDexFile(File file, File optimizedDirectory)
            throws IOException {
        if (optimizedDirectory == null) {
            return new DexFile(file);
        } else {
            String optimizedPath = optimizedPathFor(file, optimizedDirectory);
            return DexFile.loadDex(file.getPath(), optimizedPath, 0);
        }
    }

    /**
    * Converts a dex/jar file path and an output directory to an
    * output file path for an associated optimized dex file.
    */
    private static String optimizedPathFor(File path,
            File optimizedDirectory) {
        String fileName = path.getName();
        if (!fileName.endsWith(DEX_SUFFIX)) {
            int lastDot = fileName.lastIndexOf(".");
            if (lastDot < 0) {
                fileName += DEX_SUFFIX;
            } else {
                StringBuilder sb = new StringBuilder(lastDot + 4);
                sb.append(fileName, 0, lastDot);
                sb.append(DEX_SUFFIX);
                fileName = sb.toString();
            }
        }
        File result = new File(optimizedDirectory, fileName);
        return result.getPath();
    }

```

### dexclassloader
DexClassLoader可以加载jar/apk/dex，可以从SD卡中加载未安装的apk
```
public class DexClassLoader extends BaseDexClassLoader {
    public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) {
        super((String)null, (File)null, (String)null, (ClassLoader)null);
        throw new RuntimeException("Stub!");
    }
}
```
上述pathclassloader在解析父类源码是可知，optimizedDirectory自己指定，所以可以用于记载外部dex，因为这个dex会被复制到内部optimezedDirectory。
```
   ClassLoader(ClassLoader parentLoader, boolean nullAllowed) {
        if (parentLoader == null && !nullAllowed) {
            throw new NullPointerException("parentLoader == null && !nullAllowed");
        }
        parent = parentLoader;
    }
```
创建一个ClassLoader实例的时候，需要使用一个现有的ClassLoader实例作为新创建的实例的Parent。这样一来，一个Android应用，甚至整个Android系统里所有的ClassLoader实例都会被一棵树关联起来，这也是ClassLoader的 双亲代理模型（Parent-Delegation Model）的特点

### 双亲代理模型加载类
* 先查询当前classloader是否加载过这个类，有就返回
* 如果没有，则询问parent是否加载过这个类，如果parent加载过则返回parent加载的类
* 如果super继承路线上都没有加载过该类，则由child加载
* 作用
    * 共享功能，一些Framework层级的类一旦被顶层的ClassLoader加载过就缓存在内存里面，以后任何地方用到都不需要重新加载
    * 隔离功能，不同继承路线上的ClassLoader加载的类肯定不是同一个类，这样的限制避免了用户自己的代码冒充核心类库的类访问核心类库包可见成员的情况。
* 注意点
    * 如果想使用新的classloader加载dex文件替换旧的类，就必须药保证加载新类的时候旧类还没有加载，不然就会优先使用旧类
    * 或者使用一个classloader没有继承加载过旧类的树型关系父类
    * 但是java中只有当两个实例的类名，包名及classloader相同，才会被认为是同个类型。如果可能会存现类型不符合的异常
JVM中ClassLoader通过defineClass方法加载jar里面的Class，而Android中这个方法被弃用了，取而代之的是loadClass方法
```
    @Deprecated
    protected final Class<?> defineClass(byte[] classRep, int offset, int length)
            throws ClassFormatError {
        throw new UnsupportedOperationException("can't load this type of class file");
    }

    public Class<?> loadClass(String className) throws ClassNotFoundException {
        return loadClass(className, false);
    }

protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException{
        // First, check if the class has already been loaded
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            try {
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }

            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                c = findClass(name);
            }
        }
        return c;
}
//flindclass是父类basedexclassloader重载了该方法
@Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        Class clazz = pathList.findClass(name);
        if (clazz == null) {
            throw new ClassNotFoundException(name);
        }
        return clazz;
    }
//pathlist#findclass,变量了之前classloader拿到的所有dexfile实例，然后遍历查找是不是想要加载的类
    public Class findClass(String name) {
        for (Element element : dexElements) {
            DexFile dex = element.dexFile;
            if (dex != null) {
                Class clazz = dex.loadClassBinaryName(name, definingContext);
                if (clazz != null) {
                    return clazz;
                }
            }
        }
        return null;
    }
```
### 创建自己的classloader
ClassLoader双亲代理的实现很大一部分就是在loadClass方法里，我们可以通过重写loadClass方法避开双亲代理的框架，这样一来就可以在重新加载已经加载过的类，也可以在加载类的时候注入一些代码。这是一种Hack的开发方式.

* java

    * bootstrapclassloader,负责加载核心JavaClass（即所有java.*开头的类）

    *extensionclassloader,负责加载扩展的Javaclass（例如所有javax.*开头的类和存放在JRE的ext目录下的类）

    * applicationclassloader,，负责加载应用程序自身的类（我们写的类都是用ApplicationClassLoader来加载的）

* android

    * bootclassloader 系统类

    * pathclassloader，安装过apk的

    * dexclassloader，jar/apk/dex，可以从SD卡中加载未安装的apk

但是android比起java有几个麻烦点

* 组件如activity和service需要manifest注册才能使用，所以动态加载并无法工作

* res资源需要r.id注册好之后运行时通过这些id获取resource，如果动态加载新类，如果找不到id则会crash。

整体而言是context不同导致的。








